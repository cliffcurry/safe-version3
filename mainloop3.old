# this is mainloop3.py 
import calculations
import timing_constants
import globs
import timeoutTimer
import SerialConnection
import DataBaseV2
import DataBaseQuery
import DisplayStuff
import tkinter as tk
import ArdCommandResponse
import datetime
from enum import Enum
class st(Enum):
    IDLE= 11 #  #0   # ready for the card to be swiped
    WAIT_FOR_FIRST_SWIPE= 12 #  #0   # ready for the card to be swiped
    FIRST_PROX_CARD_READ= 13 #  #1   # database has been quiried, waiting for it to respond
    WAIT_TO_RESET= 14 #  #2 
    DATABASE_QUERY_TIMED_OUT= 15 #  #3
    SUPERVISOR_NEEDED_CARD= 16 #  #4
    SUPERVISOR_NEEDED_WAIT_FOR_DATA= 17 #  #8
    CONTINUE_TIMING_ACCESS= 18 #  #5
    START_TIMING_ACCESS= 180 #  #5
    EXTEND_TIME_PROMPT= 19 #  #6
    CHECK_SWITCH_STATE= 100 #  #7
    CHECK_SWITCH_STATE_IMP_MEAS= 101 #  #9
    POWER_SWITCH_CLOSED= 102 #  #10
    SERIAL_COMMAND_NOT_RESPONDING= 103 #  #12
    IMP_CHECK_FAILED= 104 #  #11
    EXTENDED_ACCESS_SWIPE = 105
    WRONG_ID_SWIPE = 106
    SUPERVISOR_NEEDED_EXTENDED =107
    PROX_SWIPE_FROM_SUPER_OBTAINED =109
    USER_INTERRUPT = 266
    GOT_USERS_ID = 267
    GOT_SUPER_ID =268
    GOT_SUPER_TABLE =269
    GOT_LAB_TABLE =270
    GOT_MACHINE_ID =271
    
    GOT_MACHINE_TABLE =272
    GOT_USER_TABLE =273
    SUPERVISOR_NEEDED_LOOKUP_NAME=274
    SET_TIMER_FOR_SWITCH_DETECT =275
    DATABASE_MISSING_DATA_ERROR =276
   
def minutes_display(seconds):
    min=seconds//60
    sec=seconds-min*60
    ss=str(sec)
    if len(ss)==1:
        ss='0'+ss
    return str(min)+":"+ss

        
def mainloop(state,first_time_here_flag):
    if (state== st.USER_INTERRUPT):
        if (first_time_here_flag==True):
            SerConn.cardID_available=False; 
            Dis.display_message_to_user('User Cancel ',1)
            Dis.display_message_to_user('',2)
            Dis.display_message_to_user('',3)
            Dis.display_message_to_user('',4)
            Dis.display_message_to_user('',5)
            timeoutTimer1.set_time(timing_constants.DISPLAY_DELAY);
            first_time_here_flag=False   
#-------    
        else:
            globs.user_touched_screen_flag=False  # reset the flag that tells the user interrupted
            if timeoutTimer1.timed_out():
                state=st.IDLE; first_time_here_flag=True;
        return state,first_time_here_flag  
    #---------------------------------------------------------
    if (state== st.IDLE):
        if (first_time_here_flag==True):
            SerConn.cardID_available=False; 
            Dis.display_message_to_user('Swipe card for Access',1)
            Dis.display_message_to_user('',2)
            Dis.display_message_to_user('',3)
            Dis.display_message_to_user('',4)
            Dis.display_message_to_user('',5)
            print("Sending Arduino message to turn off relay")
            first_time_here_flag=False   
#-------    
        else:
            globs.user_touched_screen_flag=False
            response =ACommandProc.turn_off_device()
            if response==True:
                print('device  is off')
                state= st.WAIT_FOR_FIRST_SWIPE; first_time_here_flag=True;
            elif response==False:
                print('ERROR, Device off command Failed ')
                state= st.SERIAL_COMMAND_NOT_RESPONDING; first_time_here_flag=True;
        return state,first_time_here_flag  
    #---------------------------------------------------------
    if (state== st.WAIT_FOR_FIRST_SWIPE):
        if (first_time_here_flag==True):
            SerConn.cardID_available=False; 
            Dis.display_message_to_user('Swipe card for Access',1)
            Dis.display_message_to_user('',2)
            Dis.display_message_to_user('',3)
            Dis.display_message_to_user('',4)
            Dis.display_message_to_user('',5)
            first_time_here_flag=False;
        globs.user_touched_screen_flag=False  # reset screen touch  callback flag 
        if (SerConn.cardID_available):  # WAIT FOREVER here until the card is swiped
            globs.user_cardID=SerConn.get_cardID()
            Dis.display_message_to_user('Prox Card ID',1);
            Dis.display_message_to_user(globs.user_cardID,2)
            Dis.display_message_to_user('',3)
            Dis.display_message_to_user('',4)
            Dis.display_message_to_user('',5)
            state= st.FIRST_PROX_CARD_READ ; first_time_here_flag=True;
        return (state,first_time_here_flag) 
    #---------------------------------------------------------
    if (state== st.FIRST_PROX_CARD_READ): #get the userID
        if first_time_here_flag==True:
           first_time_here_flag=False;
        else:
            (OK,globs.userID)=Data.proxcardlookup(globs.user_cardID)
            if OK==False:
                print('finished with an error, let the database guys know')  
                state= st.DATABASE_QUERY_TIMED_OUT; first_time_here_flag=True
            elif OK==True:
                print('finished with a good result, ',globs.userID)
                Dis.display_message_to_user('ID='+str(globs.userID),3)
                if globs.userID==None:
                    state= st.DATABASE_MISSING_DATA_ERROR; first_time_here_flag=True 
                else: 
                    state= st.GOT_USERS_ID ;first_time_here_flag=True
        return (state,first_time_here_flag)           
        
        
#---------------------------------------------------------
    if (state== st.GOT_USERS_ID): #get the machine ID
        if first_time_here_flag==True:
           first_time_here_flag=False;
        else:
            (OK,globs.machineID)=Data.interlocklookup(calculations.get_mac_addr())
            if OK==False:
                print('finished with an error, let the database guys know')  
                state= st.DATABASE_QUERY_TIMED_OUT; first_time_here_flag=True
            elif OK==True:
                print('finished with a good result, machineID= ',globs.machineID)
                if globs.machineID==None:
                    state= st.DATABASE_MISSING_DATA_ERROR; first_time_here_flag=True 
                else: 
                    state= st.GOT_MACHINE_ID ;first_time_here_flag=True
        return (state,first_time_here_flag)   

#------------------------------------------------------
    if (state== st.GOT_MACHINE_ID): # get the machineTable, the machine information
        if first_time_here_flag==True:
           first_time_here_flag=False;
        else:
            (OK,globs.machineTable)=Data.machineInfo(globs.machineID)
            if OK==False:
                print('finished with an error, let the database guys know')  
                state= st.DATABASE_QUERY_TIMED_OUT; first_time_here_flag=True
            elif OK==True:
                print('finished with a good result, machineTable=',globs.machineTable)
                if globs.machineTable==None:
                    state= st.DATABASE_MISSING_DATA_ERROR; first_time_here_flag=True 
                else: 
                    Dis.display_message_to_user("Machine="+globs.machineTable["textDescription"],4)
                    state= st.GOT_MACHINE_TABLE ;first_time_here_flag=True
        return (state,first_time_here_flag)   

#------------------------------------------------------
    if (state== st.GOT_MACHINE_TABLE): # get the userTable, the user information
        if first_time_here_flag==True:
           first_time_here_flag=False;
        else:
            (OK,globs.userTable)=Data.personInfo(globs.userID)
            if OK==False:
                print('finished with an error, let the database guys know')  
                state= st.DATABASE_QUERY_TIMED_OUT; first_time_here_flag=True
            elif OK==True:
                print('finished with a good result, userTable= ',globs.userTable)
                if globs.userTable==None:
                    state= st.DATABASE_MISSING_DATA_ERROR; first_time_here_flag=True 
                else: 
                    Dis.display_message_to_user(globs.userTable["personTextName"],3)
                    state= st.GOT_USER_TABLE ;first_time_here_flag=True
        return (state,first_time_here_flag)   
        
 #----------------------------------------------------
    if (state== st.DATABASE_MISSING_DATA_ERROR): # None was returned somewere
        Dis.display_message_to_user('ACCESS DENIED',3)
        Dis.display_message_to_user('because of',4)
        Dis.display_message_to_user('DATABASE: no data',5)
        state= st.WAIT_TO_RESET; first_time_here_flag=True  
        return (state,first_time_here_flag)  

        
 #----------------------------------------------------
    if (state== st.GOT_USER_TABLE): # get the labTable, the information about the labratory
        if first_time_here_flag==True:
           first_time_here_flag=False;
        else:
           
            (OK,globs.labTable)=Data.labInfo(globs.machineTable["lab"])
            if OK==False:
                print('finished with an error, let the database guys know')  
                state= st.DATABASE_QUERY_TIMED_OUT; first_time_here_flag=True
            elif OK==True:
                print('finished with a good result, labTable= ',globs.labTable)
                if globs.labTable==None:
                    state= st.DATABASE_MISSING_DATA_ERROR; first_time_here_flag=True 
                else: 
		
                    state= st.GOT_LAB_TABLE ;first_time_here_flag=True
        return (state,first_time_here_flag)          
                

#---------------------------------------------------------
    if (state== st.GOT_LAB_TABLE):  # now we have all we need, start to decide some things...
        if first_time_here_flag==True:
           first_time_here_flag=False;
        else:
            Time_Now=calculations.tominutes(datetime.datetime.now())
            print("time now=",Time_Now)         
            globs.actual_end_time=min(calculations.tominutes(globs.machineTable["endTime"]),
                                calculations.tominutes(globs.userTable["endTime"]),
                                calculations.tominutes(globs.labTable["endTime"]))
            print("actual end time=",globs.actual_end_time)
            globs.actual_start_time=max(calculations.tominutes(globs.machineTable["startTime"]),
                                calculations.tominutes(globs.userTable["startTime"]),
                                calculations.tominutes(globs.labTable["startTime"]))
            print("actual start time=",globs.actual_start_time)
            globs.user_name=globs.userTable["personTextName"]
            if globs.user_name==None:
                state= st.DATABASE_MISSING_DATA_ERROR; first_time_here_flag=True 
                return (state,first_time_here_flag)  
            else:
                Dis.display_message_to_user(globs.user_name,1)
                if globs.userTable["personClass"]=="allAccess":  # if this user is all access, just go 
                    if globs.machineTable["usesEstop"]:
                        print("All access person with an e-stop machine")
                        state=st.START_TIMING_ACCESS; first_time_here_flag=True
                        return (state,first_time_here_flag)
                    else: 
                        print("All access person with an NON e-stop machine")
                        state= st.SET_TIMER_FOR_SWITCH_DETECT ;first_time_here_flag=True
                        return (state,first_time_here_flag)
                (access,reason)=calculations.nonsupervisor_access(globs.userID,Time_Now,     # check to see if this user can use the stuff without supervisor
                                                globs.machineTable,
                                                globs.userTable,globs.labTable);
                #                                 
                if (access == False) and  (reason != "Supervisor Swipe Needed"): #  
                    Dis.display_message_to_user('ACCESS DENIED',3)
                    if (reason):
                        Dis.display_message_to_user(reason,4)
                        print("Access denied because of ",reason);
                    else:
                        Dis.display_message_to_user('Unknown reason ',4)
                    state= st.WAIT_TO_RESET;   first_time_here_flag=True 
                if access==False and reason=="Supervisor Swipe Needed":     # if a supervisor is needed for this machine 
                    if globs.userID in globs.machineTable["supervisorAccessList"]:  # if this user is on the supervisor access list, no need to get any supervisor info 
                        print("A supervisior swipe is needed for this machine, but the user is on the supervisor list")
                        globs.superTable=globs.userTable   # set the supervisor to this user. 
                        state= st.GOT_SUPER_TABLE ;  first_time_here_flag=True
                    else:    
                        print("Supervisor is needed for this machine, user is not on supervisor list")
                        state= st.SUPERVISOR_NEEDED_CARD ;  first_time_here_flag=True
                        return (state,first_time_here_flag)      
                if access==True:     # if the user has access without supervisor approval, give it to them 
                    if globs.machineTable["usesEstop"]:
                        print("User has access to this machine without supervisor. this machine uses and estop");
                        state=st.START_TIMING_ACCESS; first_time_here_flag=True
                        return (state,first_time_here_flag)
                    else: 
                        print("User has access to this machine without supervisor, this machine does NOT use an e-stop")
                        state= st.SET_TIMER_FOR_SWITCH_DETECT ;first_time_here_flag=True
                        return (state,first_time_here_flag)
        return (state,first_time_here_flag)           
    #--------------------------------------------------------------  

    
    if (state== st.SUPERVISOR_NEEDED_CARD):    
        if (first_time_here_flag==True):
            SerConn.cardID_available=False
            Dis.display_message_to_user('Supervisor req.',2);
            Dis.display_message_to_user('Ask the supervisor',3)
            Dis.display_message_to_user('to swipe card',4)
            timeoutTimer1.set_time(timing_constants.WAIT_FOR_SUPERVISOR_TIME)
            first_time_here_flag=False;   
#-------
        else:     
            if (timeoutTimer1.secondstick()):
                Dis.display_message_to_user("Waiting for " + minutes_display(timeoutTimer1.get_timeleft()),5)
            if (timeoutTimer1.timed_out()):
               state= st.IDLE ; first_time_here_flag=True;          
            if SerConn.cardID_available:
                timeoutTimer1.reset()
                globs.supervisor_cardID=SerConn.get_cardID()
                Dis.display_message_to_user('Prox Card ID ',1)
                Dis.display_message_to_user(globs.supervisor_cardID,2)
                Dis.display_message_to_user('as supervisor',3)
                Dis.display_message_to_user('',4)
                Dis.display_message_to_user('',5)
                state= st.SUPERVISOR_NEEDED_WAIT_FOR_DATA ; first_time_here_flag=True;          
        return state,first_time_here_flag 

    #--------------------------------------------------------------        
    if (state== st.DATABASE_QUERY_TIMED_OUT):    
        if (first_time_here_flag==True):
            Dis.display_message_to_user('Trouble Connecting ',1);
            Dis.display_message_to_user('to Database',2)
            Dis.display_message_to_user('',3)
            Dis.display_message_to_user('Not responding',4)
            Dis.display_message_to_user('To query',5)
            first_time_here_flag=False;
        state= st.WAIT_TO_RESET; first_time_here_flag=True;
        return state,first_time_here_flag 
#--------------------------------------------------------------              
    if (state== st.WAIT_TO_RESET):    
        if (first_time_here_flag==True):
            timeoutTimer1.set_time(timing_constants.DISPLAY_DELAY)
            first_time_here_flag=False;
        if (timeoutTimer1.timed_out()):
            state= st.IDLE; first_time_here_flag=True;
        return state,first_time_here_flag 
    #--------------------------------------------------------------              
    if (state== st.SUPERVISOR_NEEDED_WAIT_FOR_DATA):    
        if (first_time_here_flag==True):
            first_time_here_flag=False
       
 #--------           
        (OK,globs.superID)=Data.proxcardlookup(globs.supervisor_cardID)
        if OK==False:
                print('finished with an error, let the database guys know')  
                state= st.DATABASE_QUERY_TIMED_OUT; first_time_here_flag=True
        elif OK==True:
                print('finished with a good result, supervisor person ID= ',globs.superID)
                if globs.superID==None:
                    state= st.DATABASE_MISSING_DATA_ERROR; first_time_here_flag=True 
                else:
                    state= st.GOT_SUPER_ID ;first_time_here_flag=True
        return(state,first_time_here_flag);
 #--------------------------------------------------------------              
    if (state== st.GOT_SUPER_ID):    
        if (first_time_here_flag==True):
            first_time_here_flag=False
       
 #--------               
        else:
            (OK,globs.superTable)=Data.personInfo(globs.superID)
            if OK==False:
                print('finished with an error, let the database guys know')  
                state= st.DATABASE_QUERY_TIMED_OUT; first_time_here_flag=True
            elif OK==True:
                print('finished with a good result, supervisor Table Information=',globs.superTable)
                if globs.superTable==None:
                    state= st.DATABASE_MISSING_DATA_ERROR; first_time_here_flag=True 
                else: 
	                state= st.GOT_SUPER_TABLE ;first_time_here_flag=True
        return (state,first_time_here_flag)  

#--------------------------------------------------------------              
    if (state== st.GOT_SUPER_TABLE):    
        if (first_time_here_flag==True):
            first_time_here_flag=False
       
 #--------               
        else:
            Time_Now=calculations.tominutes(datetime.datetime.now())
            print("time now=",Time_Now)   
            (ok,reason)=calculations.determine_supervisor_access(globs.superID,globs.userID,Time_Now,globs.machineTable,globs.userTable,
                                globs.labTable)
            if ok:
                if globs.machineTable["usesEstop"]:
                    state=START_TIMING_ACCESS;first_time_here_flag=True
                else:
                    state= st.SET_TIMER_FOR_SWITCH_DETECT ;first_time_here_flag=True
            else:
                
                Dis.display_message_to_user('Denied',4)
                Dis.display_message_to_user(reason,5)
                state= st.WAIT_TO_RESET; first_time_here_flag=True;                   
        return state,first_time_here_flag 
    #----------------------------------------------------------------
#        calculate the time of access here, too    
    if (state== st.START_TIMING_ACCESS):        # display message to the user, send a message to the arduino to turn the device on 
        if (first_time_here_flag==True):
            Dis.display_message_to_user(globs.userTable["personTextName"],1)
            Dis.display_message_to_user('Has access for',2)
            globs.user_time_of_access=calculations.time_for_access(globs.actual_start_time, 
                        globs.actual_end_time,globs.machineTable["minutesEnabled"])
            if globs.userTable["personClass"]=="allAccess":
                globs.user_time_of_access=60*12 # all access people get 12 hours of operation. 
            timeoutTimer1.set_time(globs.user_time_of_access*60);
            Dis.display_message_to_user(minutes_display(globs.user_time_of_access),3);
            Dis.display_message_to_user('Minutes',4)
            Dis.display_message_to_user('',5)
            print("Sending Arduino message to turn on device")
            first_time_here_flag=False
#-------            
        else: 
            response=ACommandProc.turn_on_device()
            if response==False:
                    print('ERROR in arduino request to turn on the device  ')
                    state= st.SERIAL_COMMAND_NOT_RESPONDING; first_time_here_flag=True;
            elif response==True:
                    print('device  is on ')
                    state=st.CONTINUE_TIMING_ACCESS; first_time_here_flag=True
        return state,first_time_here_flag 
        
#----------------------------------------------------------------        
    if (state== st.CONTINUE_TIMING_ACCESS):        # re-display the message to the user, time the access, respond to user interrupt
        if (first_time_here_flag==True):
            Dis.display_message_to_user(globs.userTable["personTextName"],1)
            Dis.display_message_to_user('Has access for',2)
           
            timeoutTimer1.set_time(globs.user_time_of_access*60);
            Dis.display_message_to_user(minutes_display(globs.user_time_of_access),3);
            Dis.display_message_to_user('Minutes',4)
            Dis.display_message_to_user('',5)
         
            first_time_here_flag=False
#-------            
        else: 
            if globs.user_touched_screen_flag==True: # check here to see if the user wants to end use of the device 
                state=st.USER_INTERRUPT ; first_time_here_flag=True   # if so, reset system to start
                print(" Checking flag indicates that the User has interrrupted loop");                        
            if (timeoutTimer1.secondstick()):
                Dis.display_message_to_user(minutes_display(timeoutTimer1.get_timeleft()),3)
            if (timeoutTimer1.get_timeleft()<=globs.user_time_of_access//5):
                    state= st.EXTEND_TIME_PROMPT; first_time_here_flag=True
            if (timeoutTimer1.timed_out()):
                state= st.IDLE; first_time_here_flag=True;        
        return state,first_time_here_flag         
    #----------------------------------------------------------------        
    if (state== st.EXTEND_TIME_PROMPT):    # look for avaliabilty of a card swipe from reader       
        if (first_time_here_flag==True):
            SerConn.cardID_available=False
            Dis.display_message_to_user('Swipe to extend access ',5)
            timeoutTimer1.set_time(globs.user_time_of_access*60//5)
            first_time_here_flag=False
        #----    
        if (timeoutTimer1.secondstick()):
            Dis.display_message_to_user(minutes_display(timeoutTimer1.get_timeleft()),3)
        if globs.user_touched_screen_flag==True:
                state=st.USER_INTERRUPT ; first_time_here_flag=True
                globs.user_touched_screen_flag=False
                print(" Checking flag indicates that the User has interrrupted loop");                
        if (SerConn.cardID_available):
            state= st.EXTENDED_ACCESS_SWIPE ; first_time_here_flag=True;
        if (timeoutTimer1.timed_out()):
            state= st.IDLE; first_time_here_flag=True;
        return state,first_time_here_flag 
 #----------------------------------------------------------------        
    if (state== st.EXTENDED_ACCESS_SWIPE):        # got a swipe, need to check it to see if it is from the same card as before 
        cardID=SerConn.get_cardID()         # get the info 
        Dis.display_message_to_user('Prox Card ID',1);
        Dis.display_message_to_user(cardID,2)
        if cardID != globs.user_cardID: # if not same card, error out 
            state=st.WRONG_ID_SWIPE;first_time_here_flag=True;
        else:   # same card as before 
            if globs.machineTable["classOfAccess"]=="Supervised": # if the  machine require supervisor swipe?
                if globs.userID in globs.machineTable["supervisorAccessList"]:  # if this user is on the supervisor access list, no need to get any supervisor info 
                    state=st.START_TIMING_ACCESS  ; first_time_here_flag=True # 
                else: 
                    state=st.SUPERVISOR_NEEDED_LOOKUP_NAME;first_time_here_flag=True;  # if requires supervisor, and user is not on supervisor list, then go ask for  supervisor card   
            else:  ## machine does not need supervisor here 
                state=st.START_TIMING_ACCESS; first_time_here_flag=True   # if same card was used, and machine does not require supervisor swipe, extend the time. 
        return state,first_time_here_flag     
 #----------------------------------------------------------------        
    if (state== st.WRONG_ID_SWIPE):        # user tried to extend use, but used a different card 
        if (first_time_here_flag==True):
            Dis.display_message_to_user('Is not the ID ',3)
            Dis.display_message_to_user('used previously.',4)
            Dis.display_message_to_user('Access Denied',5)
            timeoutTimer1.set_time(timing_constants.DISPLAY_DELAY)
            first_time_here_flag=False;        
        if (timeoutTimer1.timed_out()):
            state= st.IDLE; first_time_here_flag=True;
        return state,first_time_here_flag           
# -------------------------------------------------------
    if (state== st.SUPERVISOR_NEEDED_LOOKUP_NAME):     #  find the name of one of the supervisiors, for use in the display 
        if (first_time_here_flag==True):
            if len(globs.machineTable["supervisorAccessList"])<1:
                print('ERROR, no entries in the supervisor list for this machine');
                state=st.DATABASE_MISSING_DATA_ERROR; first_time_here_flag=True;
                return (tate,first_time_here_flag)
            else:    
                globs.a_supervisorID= globs.machineTable["supervisorAccessList"][0]
            first_time_here_flag=False;   
#-------     
        (OK,sTable)=Data.personInfo(globs.a_supervisorID)
        if OK==False:
            print('finished with an error, let the database guys know')  
            state= st.DATABASE_QUERY_TIMED_OUT; first_time_here_flag=True
        elif OK==True:
            print('finished with a good result, Table Information about one of the supervisors=',sTable)
            if sTable==None:
                state= st.DATABASE_MISSING_DATA_ERROR; first_time_here_flag=True 
            else:
                globs.a_supervisor_name=sTable['personTextName']
                state=st.SUPERVISOR_NEEDED_EXTENDED;first_time_here_flag=True;  
        return state,first_time_here_flag     
#---------------------------------------------------------
    if (state== st.SUPERVISOR_NEEDED_EXTENDED):     #  llok for a card swipe, also look for user interrupt 
        if (first_time_here_flag==True):
            SerConn.cardID_available=False
            Dis.display_message_to_user('OK, Supervisor required',2);
            Dis.display_message_to_user('Ask '+globs.a_supervisor_name,3)
            Dis.display_message_to_user('to swipe card',4)
            timeoutTimer1.set_time(timing_constants.WAIT_FOR_SUPERVISOR_TIME)
            first_time_here_flag=False;   
#-------            
        if (timeoutTimer1.secondstick()):
            Dis.display_message_to_user("Waiting for " + minutes_display(timeoutTimer1.get_timeleft()),5)
        if (timeoutTimer1.timed_out()):
           state= st.IDLE ; first_time_here_flag=True;      
        if globs.user_touched_screen_flag==True:
            state=st.USER_INTERRUPT ; first_time_here_flag=True
            globs.user_touched_screen_flag=False
            print(" Checking flag indicates that the User has interrrupted loop");                
        if (SerConn.cardID_available):
            timeoutTimer1.reset()
            supervisor_cardID=SerConn.get_cardID()  # get the prox card number of this supervisor swipe  
            Dis.display_message_to_user('Prox Card ID ',1)
            Dis.display_message_to_user(supervisor_cardID,2);
            Dis.display_message_to_user(' ',3)
            Dis.display_message_to_user('As Supervisor',4)
            Dis.display_message_to_user('',5)
            if supervisor_cardID==globs.supervisor_cardID: # if same one as last time, then OK. 
                state= st.START_TIMING_ACCESS; first_time_here_flag=True;
            else:
                globs.supervisor_cardID=supervisor_cardID  # overwrite supervisor card ID            
                state= st.PROX_SWIPE_FROM_SUPER_OBTAINED ; first_time_here_flag=True;          
        return state,first_time_here_flag     
 #--------------------------------------------------------------              
    if (state== st.PROX_SWIPE_FROM_SUPER_OBTAINED):                    # got data from the prox card, query the database for person's ID number
        (OK,globs.superID)=Data.proxcardlookup(globs.supervisor_cardID)  # get info from this  supervisor swipe 
        if OK==False:
                print('finished with an error, let the database guys know')  
                state= st.DATABASE_QUERY_TIMED_OUT; first_time_here_flag=True
        elif OK==True:
                print('finished with a good result, ',globs.superID)
                if globs.superID==None:
                    state= st.DATABASE_MISSING_DATA_ERROR; first_time_here_flag=True 
                else:
                    state= st.GOT_SUPER_ID ;first_time_here_flag=True
        return(state,first_time_here_flag);
 #--------------------------------------------------------------              
    if (state== st.SET_TIMER_FOR_SWITCH_DETECT):     # simply starts a timeout timer, that's all.  this timer limits the time 
        if (first_time_here_flag==True):             # the program will wait for the user to turn off the switch 
            timeoutTimer1.set_time(timing_constants.CHECK_SWITCH_STATE_DURATION)  # timer 1 is used to time the overall switch turn off time 
            first_time_here_flag=False
#-------
        else:
            state= st.CHECK_SWITCH_STATE; first_time_here_flag=True 
        return(state,first_time_here_flag);
    #----------------------------------------------------------------        
    if (state== st.CHECK_SWITCH_STATE):           # if using estop, just turn on the device. 
        if (first_time_here_flag==True):          # else, let the user know we are checking the power switch, then wait for the arduino to return the impedance
            if globs.machineTable["usesEstop"]:
                state= st.START_TIMING_ACCESS; first_time_here_flag=True;
            else:
                print("Doing impedance measurement")
              
                Dis.display_message_to_user('',3)
                Dis.display_message_to_user('Checking switch',4)
                Dis.display_message_to_user("Waiting for " + minutes_display(timeoutTimer1.get_timeleft()),5)
                 
                first_time_here_flag=False
        else:        
#-------         
            (OK,val) = ACommandProc.complete_impedance_measure()     # This commmand takes some time to finish 
            if OK==False:
                print('ERROR in measuring impedance ')
                state=st.SERIAL_COMMAND_NOT_RESPONDING; first_time_here_flag=False
            if OK==True:
                print('Impedance measurement is good, value= ',val)
                if val>20000:
                    state= st.START_TIMING_ACCESS; first_time_here_flag=True;   # switch is off, so turn the device on 
                else:
                    state= st.IMP_CHECK_FAILED; first_time_here_flag=True;      # switch is on, so let the user know
        return state,first_time_here_flag             
    #----------------------------------------------------------------        
   
 #----------------------------------------------------------------          
    if (state== st.IMP_CHECK_FAILED):                               # tell the user to turn off the switch. wait for a short time so the user can read the info 
        if (first_time_here_flag==True):                            #  also check the timer to see if the time allowed for the user to turn the switch is expired 
            print("Here because of failed impedance test")
            print("Tell user to turn off the power switch")
            Dis.display_message_to_user('Turn Off switch',4)
            Dis.display_message_to_user("Waiting for " + minutes_display(timeoutTimer1.get_timeleft()),5)
            timeoutTimer2.set_time(timing_constants.DISPLAY_DELAY)    # timer 2 is used only to time this message duration. 
            
            first_time_here_flag=False
#-------            
        if timeoutTimer1.timed_out():           # timer 1 is used to time the overall switch detection process
            state= st.IDLE; first_time_here_flag=True            
        elif  (timeoutTimer2.timed_out()):      # timer 2 is used to time the display of this particular message
            state= st.CHECK_SWITCH_STATE; first_time_here_flag=True 
            
        return state,first_time_here_flag            
   
    #----------------------------------------------------------------          
      
  #----------------------------------------------------------------          
    if (state== st.SERIAL_COMMAND_NOT_RESPONDING):        
        if (first_time_here_flag==True):
            print("Here Because the arduino was sent a command and it did not respond")
            Dis.display_message_to_user('COMMUNICATION ERROR',4)
            timeoutTimer1.set_time(timing_constants.DISPLAY_ERROR_DELAY)
            print("This is just a delay state so the user can read the message")
            print('Send an arduino message to turn the relay off')
            
            first_time_here_flag=False
        OK=ACommandProc.turn_off_device()
        if OK==False:
            print('error in arduino request to turn off device ')
                
        if  timeoutTimer1.timed_out():
            
            state= st.IDLE; first_time_here_flag=True                    
        return state,first_time_here_flag    



        
if  __name__ == "__main__":     

   
    SerConn=SerialConnection.SerialClass()
    stophere=True
    while stophere:    # wait here for the arduino to reset and start sending stuff
        SerConn.attempt_to_get_readings(); 
        if SerConn.cardID_available:
            print("cardID=",SerConn.get_cardID())
        if SerConn.alive_available:
            print("alive=",SerConn.get_alive()) 
            stophere=False # an alive message means the arduinois awakened
    ACommandProc=ArdCommandResponse.ArdCommandResponse(SerConn)
    fake_database=DataBaseV2.DataBase()
    Data=DataBaseQuery.DataBaseQuery(fake_database)
    timeoutTimer1=timeoutTimer.timeoutTimer()
    timeoutTimer2=timeoutTimer.timeoutTimer()
    displayscreen = tk.Tk()
    displayscreen.overrideredirect(True)
    Dis=DisplayStuff.Display(displayscreen);
    timeoutTimer1.set_time(timing_constants.DISPLAY_SOFTWARE_VERSION_TIME)
    while not timeoutTimer1.timed_out():
        pass
    GlobalState= st.IDLE
    print("initial state=",GlobalState)
    flag=True
    while True:
        displayscreen.update_idletasks()
        displayscreen.update()
        SerConn.attempt_to_get_readings();
        #if flag:
            #print("STATE=",GlobalState)
        (s,f)=mainloop(GlobalState,flag);
        
        if f:
            print("newstate=",s)
        (GlobalState,flag) = (s,f)   
        
                
                
